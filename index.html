<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Camera Shutter Calibrator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 32px 16px;
        }
        /* Custom scrollbar for table on desktop */
        #history-table-container::-webkit-scrollbar {
            height: 8px;
        }
        #history-table-container::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 4px;
        }
        #history-table-container::-webkit-scrollbar-track {
            background: #f3f4f6;
        }
        .header-sticky th {
            position: sticky;
            top: 0;
            background-color: #e5e7eb;
            z-index: 10;
        }
    </style>
</head>
<body class="antialiased">

    <div id="app" class="w-full max-w-4xl bg-white p-6 md:p-10 rounded-xl shadow-2xl border-t-8 border-indigo-600">
        <h1 class="text-3xl font-extrabold text-gray-900 mb-2">Analog Shutter Calibrator</h1>
        <p class="text-gray-500 mb-6">Test the consistency and accuracy of your camera's shutter mechanism.</p>

        <!-- Accuracy Note -->
        <div id="accuracy-note" class="p-3 mb-6 rounded-lg bg-red-50 border-l-4 border-red-400 text-xs text-red-800">
            Important Accuracy Notes: Only use this in a quiet environment, putting your micriphone as close to the shutter as possible without damaging it. This method works best for speeds up to 1/1000s. Accurate measurement at 1/4000s (0.25ms) is extremely difficult due to hardware resolution and processing latency. Use a dedicated sensor for high-speed analysis.
        </div>
        
        <!-- Controls and Configuration -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <div class="md:col-span-1">
                <label for="nominal-speed" class="block text-sm font-medium text-gray-700 mb-1">Nominal Shutter Speed</label>
                <select id="nominal-speed" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-indigo-500 focus:border-indigo-500 transition duration-150">
                    <option value="1">1s</option>
                    <option value="0.5">1/2s</option>
                    <option value="0.25">1/4s</option>
                    <option value="0.125">1/8s</option>
                    <option value="0.0625">1/15s</option>
                    <option value="0.03125">1/30s</option>
                    <option value="0.015625">1/60s</option>
                    <option value="0.0078125" selected>1/125s (Default)</option>
                    <option value="0.00390625">1/250s</option>
                    <option value="0.001953125">1/500s</option>
                    <option value="0.0009765625">1/1000s</option>
                </select>
            </div>
            <button id="start-continuous-button" class="md:col-span-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-150 ease-in-out shadow-md hover:shadow-lg disabled:opacity-50 h-full" onclick="startContinuousMeasurement()">
                Start Continuous Test
            </button>
            <button id="stop-button" class="md:col-span-1 bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg transition duration-150 ease-in-out shadow-md hover:shadow-lg disabled:opacity-50 h-full" disabled onclick="stopContinuousMeasurement()">
                Stop Test and Summarize
            </button>
        </div>

        <!-- Status Display -->
        <div id="status-display" class="p-4 mb-6 rounded-lg bg-yellow-50 border-l-4 border-yellow-400 text-sm text-yellow-800 font-medium">
            Select a nominal speed and click 'Start Continuous Test'.
        </div>

        <!-- Current Cycle Results -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-8">
            <div class="bg-gray-100 p-6 rounded-lg shadow-inner">
                <p class="text-sm font-semibold text-gray-600 mb-1">Last Measured Time</p>
                <span id="time-display" class="text-5xl font-extrabold text-indigo-600">0.000</span>
                <span class="text-xl font-light text-indigo-600 ml-1">ms</span>
            </div>
            <div class="bg-gray-100 p-6 rounded-lg shadow-inner">
                <p class="text-sm font-semibold text-gray-600 mb-1">Total Measurements Taken</p>
                <span id="cycle-count" class="text-5xl font-extrabold text-green-700">0</span>
                <span class="text-xl font-light text-green-700 ml-1">cycles</span>
            </div>
        </div>

        <!-- History Table -->
        <h2 class="text-xl font-bold text-gray-900 mb-3">Measurement History</h2>
        <div id="history-table-container" class="overflow-x-auto border border-gray-200 rounded-lg shadow-sm">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-200 header-sticky">
                    <tr>
                        <th scope="col" class="px-3 py-3 text-left text-xs font-semibold text-gray-700 uppercase tracking-wider">Nominal</th>
                        <th scope="col" class="px-3 py-3 text-left text-xs font-semibold text-gray-700 uppercase tracking-wider">Cycles</th>
                        <th scope="col" class="px-3 py-3 text-left text-xs font-semibold text-gray-700 uppercase tracking-wider">Min (ms)</th>
                        <th scope="col" class="px-3 py-3 text-left text-xs font-semibold text-gray-700 uppercase tracking-wider">Max (ms)</th>
                        <th scope="col" class="px-3 py-3 text-left text-xs font-semibold text-gray-700 uppercase tracking-wider">Avg (ms)</th>
                        <th scope="col" class="px-3 py-3 text-left text-xs font-semibold text-gray-700 uppercase tracking-wider">Diff (ms)</th>
                    </tr>
                </thead>
                <tbody id="results-table-body" class="bg-white divide-y divide-gray-100">
                    <!-- Results will be injected here -->
                </tbody>
            </table>
            <p id="no-results-message" class="p-4 text-center text-gray-500 italic text-sm">No tests recorded yet.</p>
        </div>
    </div>

    <script>
        // --- Web Audio and State Management ---

        let audioContext;
        let analyser;
        let dataArray;
        let mediaStreamSource;
        let animationFrameId;
        let isContinuousMode = false;
        let currentMeasurements = [];
        let allTestSets = []; // Stores summarized results

        const STATE = {
            IDLE: 0,
            LISTENING: 1,
            PEAK1_DETECTED: 2,
            PROCESSING: 3,
            ERROR: 4,
        };

        let currentState = STATE.IDLE;
        let startTime = 0; // Performance.now() timestamp of the first peak
        const fftSize = 2048; 
        const bufferLength = fftSize;

        // Customizable settings
        const DETECTION_THRESHOLD = 150; // Amplitude threshold (0-128 deviation from 128)
        const MIN_DURATION_MS = 1; // Minimum time required between Peak 1 and Peak 2
        const MAX_DURATION_MS = 3000; // Maximum time to wait for the second peak

        // DOM Elements
        const statusDisplay = document.getElementById('status-display');
        const timeDisplay = document.getElementById('time-display');
        const cycleCountDisplay = document.getElementById('cycle-count');
        const startButton = document.getElementById('start-continuous-button');
        const stopButton = document.getElementById('stop-button');
        const nominalSpeedSelect = document.getElementById('nominal-speed');
        const resultsTableBody = document.getElementById('results-table-body');
        const noResultsMessage = document.getElementById('no-results-message');

        /**
         * Updates the UI status message.
         */
        function updateStatus(message, styleClass = 'bg-yellow-50 border-yellow-400 text-yellow-800') {
            statusDisplay.className = `p-4 mb-6 rounded-lg border-l-4 text-sm font-medium ${styleClass}`;
            statusDisplay.innerHTML = message;
        }

        /**
         * The main audio processing loop.
         */
        function processAudio() {
            if (currentState === STATE.IDLE || currentState === STATE.PROCESSING) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            // Get time domain data
            analyser.getByteTimeDomainData(dataArray);

            // Calculate the max absolute peak volume in the current buffer
            let maxVolume = 0;
            for (let i = 0; i < bufferLength; i++) {
                // Data is 0-255, where 128 is silence.
                const amplitude = Math.abs(dataArray[i] - 128);
                if (amplitude > maxVolume) {
                    maxVolume = amplitude;
                }
            }

            const currentTime = performance.now();

            // --- State Machine Logic ---

            if (currentState === STATE.LISTENING) {
                if (maxVolume > DETECTION_THRESHOLD) {
                    // Peak 1 Detected (Curtain Open)
                    startTime = currentTime;
                    currentState = STATE.PEAK1_DETECTED;
                    updateStatus(`&#9679; Curtain Open Detected. Listening for close...`, 'bg-blue-50 border-blue-400 text-blue-800');
                }
            } else if (currentState === STATE.PEAK1_DETECTED) {
                const duration = currentTime - startTime;

                // Check for Timeout
                if (duration > MAX_DURATION_MS) {
                    // Stop the entire test set if timeout occurs
                    currentState = STATE.ERROR;
                    stopContinuousMeasurement();
                    updateStatus(`&#9888; Timeout (${duration.toFixed(0)}ms): Max time exceeded. Test stopped.`, 'bg-red-50 border-red-400 text-red-800');
                    return;
                }

                // Check for Second Peak
                if (maxVolume > DETECTION_THRESHOLD) {
                    if (duration > MIN_DURATION_MS) {
                        // Peak 2 Detected (Curtain Close)
                        currentState = STATE.PROCESSING;
                        const effectiveDuration = duration;

                        // Record the measurement
                        currentMeasurements.push(effectiveDuration);
                        timeDisplay.textContent = effectiveDuration.toFixed(3);
                        cycleCountDisplay.textContent = currentMeasurements.length;

                        updateStatus(`&#10003; Cycle ${currentMeasurements.length} complete: ${effectiveDuration.toFixed(3)}ms. Awaiting next shutter release...`, 'bg-green-50 border-green-400 text-green-800');

                        // Immediately stop and restart if in continuous mode
                        stopListening(); 
                        if (isContinuousMode) {
                            // Wait briefly to allow camera handling, then restart
                            setTimeout(startCycle, 500); 
                        }

                        return;
                    } else {
                        // Ignore short noise, reset start time for a proper detection window
                        startTime = currentTime; 
                    }
                }
            }

            animationFrameId = requestAnimationFrame(processAudio);
        }

        /**
         * Starts a single measurement cycle (used by the continuous loop).
         */
        async function startCycle() {
            if (currentState !== STATE.IDLE) {
                return;
            }
            
            // Set up UI for listening phase
            startButton.disabled = true;
            stopButton.disabled = false;
            nominalSpeedSelect.disabled = true;
            
            try {
                // Initialize Audio Context and Nodes
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = fftSize;
                dataArray = new Uint8Array(bufferLength);
                
                // Get Microphone Access
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                mediaStreamSource = audioContext.createMediaStreamSource(stream);
                mediaStreamSource.connect(analyser);

                currentState = STATE.LISTENING;
                updateStatus(`&#127908; Listening for Cycle ${currentMeasurements.length + 1}. Fire the shutter now!`, 'bg-blue-50 border-blue-400 text-blue-800');
                
                // Start the processing loop
                animationFrameId = requestAnimationFrame(processAudio);

            } catch (error) {
                console.error("Microphone access error:", error);
                // Stop the entire test set if we lose the mic
                stopContinuousMeasurement();
                updateStatus(`&#10060; Error: Could not access microphone. ${error.message}`, 'bg-red-100 border-red-600 text-red-900');
                currentState = STATE.ERROR;
            }
        }
        
        /**
         * Initiates the continuous measurement loop.
         */
        function startContinuousMeasurement() {
            if (isContinuousMode) return;
            
            isContinuousMode = true;
            currentMeasurements = [];
            cycleCountDisplay.textContent = 0;
            timeDisplay.textContent = '0.000';
            
            startButton.textContent = 'Running...';
            startButton.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
            startButton.classList.add('bg-gray-400');
            
            // This starts the first cycle, which will recursively call itself
            startCycle();
        }


        /**
         * Stops all audio processing and summarizes results.
         */
        function stopContinuousMeasurement() {
            if (!isContinuousMode) return;
            
            isContinuousMode = false;
            stopListening();
            resetUI();
            
            if (currentMeasurements.length > 0) {
                // Summarize the data and update the table
                addResultToTable(currentMeasurements);
                currentMeasurements = []; // Clear for next test
                updateStatus(`&#9989; Test Set Complete! ${allTestSets[allTestSets.length-1].cycles} cycles recorded.`, 'bg-green-500 border-green-600 text-white');
            } else {
                 updateStatus(`Test stopped. No cycles were recorded in this set.`, 'bg-yellow-50 border-yellow-400 text-yellow-800');
            }
        }
        
        /**
         * Stops the underlying Web Audio API connections.
         */
        function stopListening() {
            if (mediaStreamSource) {
                const tracks = mediaStreamSource.mediaStream.getTracks();
                tracks.forEach(track => track.stop());
                mediaStreamSource.disconnect();
                mediaStreamSource = null;
            }
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close().catch(e => console.error("Error closing audio context:", e));
                audioContext = null;
            }

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            currentState = STATE.IDLE;
        }

        /**
         * Resets the UI controls after a test set completes.
         */
        function resetUI() {
            startButton.disabled = false;
            startButton.textContent = "Start Continuous Test";
            startButton.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
            startButton.classList.remove('bg-gray-400');
            
            stopButton.disabled = true;
            nominalSpeedSelect.disabled = false;
        }

        /**
         * Calculates summary stats and adds a row to the history table.
         * @param {number[]} measurements The array of effective exposure times in ms.
         */
        function addResultToTable(measurements) {
            if (measurements.length === 0) return;

            const min = Math.min(...measurements);
            const max = Math.max(...measurements);
            const avg = measurements.reduce((a, b) => a + b, 0) / measurements.length;
            const diff = max - min;
            
            const nominalValue = nominalSpeedSelect.options[nominalSpeedSelect.selectedIndex].text;

            const summary = {
                nominal: nominalValue,
                cycles: measurements.length,
                min: min,
                max: max,
                avg: avg,
                diff: diff,
            };

            allTestSets.push(summary);

            // Create new table row
            const row = resultsTableBody.insertRow(0); // Insert at top
            
            const nominalCell = row.insertCell();
            nominalCell.className = "px-3 py-3 whitespace-nowrap text-sm font-medium text-gray-900";
            nominalCell.textContent = summary.nominal;
            
            const cyclesCell = row.insertCell();
            cyclesCell.className = "px-3 py-3 whitespace-nowrap text-sm text-gray-500";
            cyclesCell.textContent = summary.cycles;

            const minCell = row.insertCell();
            minCell.className = "px-3 py-3 whitespace-nowrap text-sm text-gray-500";
            minCell.textContent = summary.min.toFixed(3);

            const maxCell = row.insertCell();
            maxCell.className = "px-3 py-3 whitespace-nowrap text-sm text-gray-500";
            maxCell.textContent = summary.max.toFixed(3);

            const avgCell = row.insertCell();
            avgCell.className = "px-3 py-3 whitespace-nowrap text-sm text-gray-500";
            avgCell.textContent = summary.avg.toFixed(3);

            const diffCell = row.insertCell();
            diffCell.className = `px-3 py-3 whitespace-nowrap text-sm font-semibold ${
                summary.diff > summary.avg * 0.1 ? 'text-red-600' : 'text-green-600'
            }`; // Highlight if difference is more than 10% of average
            diffCell.textContent = summary.diff.toFixed(3);

            noResultsMessage.style.display = 'none'; // Hide the "No results" message
        }

        // Initial setup
        resetUI(); 
    </script>
</body>
</html>
